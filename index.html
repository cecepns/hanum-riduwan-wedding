<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>💒 Wedding Frame - Hanum & Riduwan</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>💒 Wedding Frame</h1>
            <h2 style="font-size: 1.8rem; margin: 10px 0; font-weight: 400; color: #ffd700;">Hanum & Riduwan</h2>
            <p>Ambil foto atau video dan tambahkan bingkai khusus untuk pernikahan kami</p>
            <div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.15); border-radius: 12px; font-size: 0.9rem; border: 1px solid rgba(255,215,0,0.3);">
                💍 <strong>Special Wedding Frame</strong> • 📱 Output: 1080x1920 (Reels/Portrait)
            </div>
        </div>

        <div class="main-content">
            <div id="status" class="status" style="display: none;"></div>

            <div class="preview-container" id="previewContainer">
                <div class="placeholder">
                    <div>💒</div>
                    <p>Mulai kamera atau upload file untuk melihat preview</p>
                    <p style="font-size: 0.85rem; color: #888; margin-top: 8px;">Bingkai khusus pernikahan Hanum & Riduwan</p>
                </div>
            </div>

            <video id="videoPreview" class="video-preview" autoplay muted playsinline style="display: none;"></video>
            
            <div class="canvas-container" id="canvasContainer" style="display: none;">
                <canvas id="canvasOutput" class="canvas-output"></canvas>
                <img id="frameOverlay" class="frame-overlay" src="bingkai.png" alt="Bingkai">
            </div>

            <div class="preview-download-section" style="text-align: center; margin: 20px 0;">
                <button id="downloadResultPreview" class="btn btn-success" disabled style="padding: 12px 24px; font-size: 1.1rem; font-weight: 600;">
                    📥 Download Hasil
                </button>
            </div>

            <div class="download-section">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <a id="downloadLink" class="download-btn" style="display: none;">
                    Download Hasil
                </a>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>📷 Kamera</h3>
                    <button id="startCamera" class="btn">Mulai Kamera</button>
                    <button id="stopCamera" class="btn btn-secondary" disabled>Stop Kamera</button>
                    <button id="capturePhoto" class="btn btn-success" disabled>Ambil Foto</button>
                    <!-- <button id="startVideo" class="btn btn-success" disabled>Mulai Video</button> -->
                    <!-- <button id="stopVideo" class="btn btn-danger" disabled>Stop Video</button> -->
                </div>

                <div class="control-group">
                    <h3>📁 Upload File</h3>
                    <label for="fileInput" class="file-label">
                        Pilih Foto/Video
                    </label>
                    <input type="file" id="fileInput" class="file-input" accept="image/*,video/*">
                    <p style="margin-top: 10px; font-size: 0.9rem; color: #6c757d;">
                        Dukungan: JPG, PNG, MP4, WebM
                    </p>
                    <p style="margin-top: 5px; font-size: 0.9rem; color: #d4a574; font-weight: 500;">
                        💒 Wedding Frame • 📱 1080x1920 (Reels)
                    </p>
                </div>

                <div class="control-group">
                    <h3>⚙️ Pengaturan</h3>
                    <button id="resetAll" class="btn btn-secondary">Reset Semua</button>
                    <button id="downloadResult" class="btn btn-success" disabled>Download Hasil</button>
                    <a href="https://drive.google.com/drive/folders/1U7lg3U5U_oxqkrN48tZ0IudGTQQz6xpO" target="_blank" class="btn" disabled>Upload ke drive</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Load FFmpeg.js from CDN -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.2/dist/umd/util.js"></script>
    <script src="video-processor-ffmpeg-umd.js"></script>
    <script>
        
        class PhotoFrameApp {
            constructor() {
                this.stream = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.isRecording = false;
                this.currentMode = null; // 'photo', 'video', 'upload'
                this.videoProcessor = null; // Will be initialized
                this.uploadedVideoFile = null; // Store original uploaded video file
                this.recordedVideoBlob = null; // Store recorded video blob
                
                this.initializeElements();
                this.bindEvents();
                this.initializeVideoProcessor();
            }

            initializeElements() {
                // Buttons
                this.startCameraBtn = document.getElementById('startCamera');
                this.stopCameraBtn = document.getElementById('stopCamera');
                this.capturePhotoBtn = document.getElementById('capturePhoto');
                this.startVideoBtn = document.getElementById('startVideo');
                this.stopVideoBtn = document.getElementById('stopVideo');
                this.resetAllBtn = document.getElementById('resetAll');
                this.downloadResultBtn = document.getElementById('downloadResult');
                this.downloadResultPreviewBtn = document.getElementById('downloadResultPreview');

                // Elements
                this.videoPreview = document.getElementById('videoPreview');
                this.canvasOutput = document.getElementById('canvasOutput');
                this.canvasContainer = document.getElementById('canvasContainer');
                this.frameOverlay = document.getElementById('frameOverlay');
                this.previewContainer = document.getElementById('previewContainer');
                this.fileInput = document.getElementById('fileInput');
                this.status = document.getElementById('status');
                this.downloadLink = document.getElementById('downloadLink');
                this.progressBar = document.getElementById('progressBar');
                this.progressFill = document.getElementById('progressFill');

                // Canvas context
                this.ctx = this.canvasOutput.getContext('2d');
            }

            bindEvents() {
                this.startCameraBtn.addEventListener('click', () => this.startCamera());
                this.stopCameraBtn.addEventListener('click', () => this.stopCamera());
                this.capturePhotoBtn.addEventListener('click', () => this.capturePhoto());
                // Video recording buttons are commented out in HTML
                if (this.startVideoBtn) {
                    this.startVideoBtn.addEventListener('click', () => this.startVideoRecording());
                }
                if (this.stopVideoBtn) {
                    this.stopVideoBtn.addEventListener('click', () => this.stopVideoRecording());
                }
                this.resetAllBtn.addEventListener('click', () => this.resetAll());
                this.downloadResultBtn.addEventListener('click', () => this.downloadResult());
                this.downloadResultPreviewBtn.addEventListener('click', () => this.downloadResult());
                this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
            }

            async initializeVideoProcessor() {
                try {
                    // Initialize the new FFmpeg-based video processor
                    this.videoProcessor = new VideoProcessor();
                    await this.videoProcessor.initialize();
                    await this.videoProcessor.loadFrame('bingkai.png');
                    
                    // Show format capability status
                    if (this.videoProcessor.supportsMP4()) {
                        console.log('Video processor initialized with MP4 support');
                        this.showStatus('Siap memproses video dalam format MP4 berkualitas tinggi!', 'success');
                    } else {
                        console.log('Video processor initialized with fallback mode');
                        this.showStatus('Siap memproses video - Hasil akan disimpan sebagai MP4', 'success');
                    }
                } catch (error) {
                    console.error('Failed to initialize video processor:', error);
                    this.showStatus('Gagal menginisialisasi processor video', 'error');
                }
            }

            showStatus(message, type = 'info') {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
                
                setTimeout(() => {
                    this.status.style.display = 'none';
                }, 5000);
            }

            setDownloadButtonsEnabled(enabled) {
                this.downloadResultBtn.disabled = !enabled;
                this.downloadResultPreviewBtn.disabled = !enabled;
            }

            async startCamera() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user'
                        },
                        audio: true // Enable audio recording
                    });

                    // Clear preview container and add video inside it
                    this.previewContainer.innerHTML = '';
                    this.videoPreview.srcObject = this.stream;
                    this.videoPreview.style.display = 'block';
                    this.previewContainer.appendChild(this.videoPreview);
                    this.previewContainer.classList.add('has-content');

                    this.startCameraBtn.disabled = true;
                    this.stopCameraBtn.disabled = false;
                    this.capturePhotoBtn.disabled = false;
                    if (this.startVideoBtn) {
                        this.startVideoBtn.disabled = false;
                    }

                    this.showStatus('Kamera berhasil dimulai!', 'success');
                } catch (error) {
                    this.showStatus('Gagal mengakses kamera: ' + error.message, 'error');
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }

                if (this.isRecording) {
                    this.stopVideoRecording();
                }

                // Reset preview container to placeholder
                this.previewContainer.innerHTML = `
                    <div class="placeholder">
                        <div>💒</div>
                        <p>Mulai kamera atau upload file untuk melihat preview</p>
                        <p style="font-size: 0.85rem; color: #888; margin-top: 8px;">Bingkai khusus pernikahan Hanum & Riduwan</p>
                    </div>
                `;
                this.videoPreview.style.display = 'none';
                this.canvasContainer.style.display = 'none';
                this.previewContainer.classList.remove('has-content');

                this.startCameraBtn.disabled = false;
                this.stopCameraBtn.disabled = true;
                this.capturePhotoBtn.disabled = true;
                if (this.startVideoBtn) {
                    this.startVideoBtn.disabled = true;
                }
                if (this.stopVideoBtn) {
                    this.stopVideoBtn.disabled = true;
                }

                this.showStatus('Kamera dihentikan', 'info');
            }

            capturePhoto() {
                if (!this.stream) {
                    this.showStatus('Kamera belum dimulai', 'error');
                    return;
                }

                // Set canvas size to reels format (1080x1920 - portrait)
                const targetWidth = 1080;
                const targetHeight = 1920;
                
                // Force canvas dimensions
                this.canvasOutput.width = targetWidth;
                this.canvasOutput.height = targetHeight;
                this.canvasOutput.style.width = '270px';
                this.canvasOutput.style.height = '480px';

                // Calculate scaling to fit video content within reels format
                const videoWidth = this.videoPreview.videoWidth;
                const videoHeight = this.videoPreview.videoHeight;
                
                // Calculate aspect ratios - for portrait reels, we want to FILL the canvas
                const videoAspect = videoWidth / videoHeight;
                const targetAspect = targetWidth / targetHeight; // 1080/1920 = 0.5625
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                // Always FILL the canvas (crop if needed) - this ensures no black bars
                if (videoAspect > targetAspect) {
                    // Video is wider than target, fit to height (crop sides)
                    drawHeight = targetHeight;
                    drawWidth = targetHeight * videoAspect;
                    offsetX = (targetWidth - drawWidth) / 2; // Center horizontally
                    offsetY = 0;
                } else {
                    // Video is taller than target, fit to width (crop top/bottom)
                    drawWidth = targetWidth;
                    drawHeight = targetWidth / videoAspect;
                    offsetX = 0;
                    offsetY = (targetHeight - drawHeight) / 2; // Center vertically
                }

                // Fill canvas with black background first
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, targetWidth, targetHeight);

                // Draw video frame to canvas with proper scaling
                this.ctx.drawImage(this.videoPreview, offsetX, offsetY, drawWidth, drawHeight);

                // Load and draw frame overlay
                const frameImg = new Image();
                frameImg.onload = () => {
                    // Draw frame overlay to cover entire canvas
                    this.ctx.drawImage(frameImg, 0, 0, targetWidth, targetHeight);
                    
                    // Show canvas with frame inside preview container
                    this.previewContainer.innerHTML = '';
                    this.canvasContainer.style.display = 'block';
                    this.previewContainer.appendChild(this.canvasContainer);
                    this.videoPreview.style.display = 'none';
                    this.setDownloadButtonsEnabled(true);
                    
                    // Debug: Log canvas dimensions and scaling info
                    console.log('=== CAPTURE PHOTO DEBUG ===');
                    console.log('Video size:', videoWidth, 'x', videoHeight);
                    console.log('Video aspect ratio:', videoAspect.toFixed(3));
                    console.log('Target aspect ratio:', targetAspect.toFixed(3));
                    console.log('Canvas size:', this.canvasOutput.width, 'x', this.canvasOutput.height);
                    console.log('Draw size:', drawWidth, 'x', drawHeight);
                    console.log('Draw offset:', offsetX, offsetY);
                    console.log('========================');
                    
                                            this.currentMode = 'photo';
                        this.showStatus('Foto pernikahan berhasil diambil dengan bingkai khusus Hanum & Riduwan!', 'success');
                };
                frameImg.src = 'bingkai.png';
            }

            startVideoRecording() {
                if (!this.stream) {
                    this.showStatus('Kamera belum dimulai', 'error');
                    return;
                }

                this.recordedChunks = [];
                
                // Use stable codec optimized for longer recordings
                let options = {};
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {
                    options.mimeType = 'video/webm;codecs=vp8,opus';
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264,opus')) {
                    options.mimeType = 'video/webm;codecs=h264,opus';
                } else {
                    options.mimeType = 'video/webm';
                }
                // Reduced bitrates for better stability on longer recordings
                options.videoBitsPerSecond = 2500000; // 2.5 Mbps for stability
                options.audioBitsPerSecond = 128000; // 128 kbps for audio
                
                this.mediaRecorder = new MediaRecorder(this.stream, options);
                
                console.log('MediaRecorder initialized with:', options.mimeType);

                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                        console.log('Recording chunk received:', event.data.size, 'bytes. Total chunks:', this.recordedChunks.length);
                    }
                };

                this.mediaRecorder.onstop = () => {
                    console.log('Recording stopped. Total chunks:', this.recordedChunks.length);
                    const blob = new Blob(this.recordedChunks, { type: options.mimeType || 'video/webm' });
                    console.log('Recorded blob size:', blob.size, 'bytes');
                    
                    const url = URL.createObjectURL(blob);
                    
                    // Create video element for preview
                    const videoElement = document.createElement('video');
                    videoElement.src = url;
                    videoElement.controls = true;
                    videoElement.style.width = '270px';
                    videoElement.style.height = '480px';
                    videoElement.style.borderRadius = '10px';
                    videoElement.style.objectFit = 'cover';
                    videoElement.style.background = '#000';
                    videoElement.muted = false;
                    videoElement.volume = 1.0;
                    
                    // Clear preview container and add video
                    this.previewContainer.innerHTML = '';
                    this.previewContainer.appendChild(videoElement);
                    this.previewContainer.classList.add('has-content');
                    
                    this.videoPreview.style.display = 'none';
                    this.canvasContainer.style.display = 'none';
                    
                    this.setDownloadButtonsEnabled(true);
                    this.currentMode = 'video';
                    this.recordedVideoBlob = blob;
                    
                    this.showStatus('Video pernikahan berhasil direkam!', 'success');
                };

                this.mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event);
                    this.showStatus('Error saat merekam: ' + event.error, 'error');
                };

                // Start recording with small chunks for better handling of long recordings
                this.mediaRecorder.start(1000); // 1 second chunks for better stability
                console.log('Recording started with 1s chunks');
                this.isRecording = true;
                if (this.startVideoBtn) {
                    this.startVideoBtn.disabled = true;
                }
                if (this.stopVideoBtn) {
                    this.stopVideoBtn.disabled = false;
                }
                this.capturePhotoBtn.disabled = true;

                this.showStatus('Perekaman video dimulai...', 'info');
            }

            stopVideoRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    if (this.startVideoBtn) {
                        this.startVideoBtn.disabled = false;
                    }
                    if (this.stopVideoBtn) {
                        this.stopVideoBtn.disabled = true;
                    }
                    this.capturePhotoBtn.disabled = false;
                }
            }

            handleFileUpload(event) {
                console.log('=== FILE UPLOAD DEBUG ===');
                const file = event.target.files[0];
                console.log('Selected file:', file);
                if (!file) {
                    console.log('No file selected');
                    return;
                }

                const isImage = file.type.startsWith('image/');
                const isVideo = file.type.startsWith('video/');
                console.log('File type:', file.type, 'isImage:', isImage, 'isVideo:', isVideo);

                if (!isImage && !isVideo) {
                    console.log('Unsupported file format');
                    this.showStatus('Format file tidak didukung', 'error');
                    return;
                }

                if (isImage) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.processImageFile(e.target.result);
                    };
                    reader.readAsDataURL(file);
                } else {
                    // Store original video file for processing
                    this.uploadedVideoFile = file;
                    this.processVideoFile(file);
                }
            }

            processImageFile(dataUrl) {
                console.log('=== PROCESS IMAGE FILE ===');
                console.log('Processing image with dataUrl length:', dataUrl.length);
                const img = new Image();
                img.onload = () => {
                    console.log('Image loaded successfully');
                    // Set canvas size to reels format (1080x1920 - portrait)
                    const targetWidth = 1080;
                    const targetHeight = 1920;
                    
                    // Force canvas dimensions
                    this.canvasOutput.width = targetWidth;
                    this.canvasOutput.height = targetHeight;
                    this.canvasOutput.style.width = '270px';
                    this.canvasOutput.style.height = '480px';

                    // Calculate scaling to fit image content within reels format
                    const imageWidth = img.width;
                    const imageHeight = img.height;
                    
                    // Calculate aspect ratios - for portrait reels, we want to FILL the canvas
                    const imageAspect = imageWidth / imageHeight;
                    const targetAspect = targetWidth / targetHeight; // 1080/1920 = 0.5625
                    
                    let drawWidth, drawHeight, offsetX, offsetY;
                    
                    // Always FILL the canvas (crop if needed) - this ensures no black bars
                    if (imageAspect > targetAspect) {
                        // Image is wider than target, fit to height (crop sides)
                        drawHeight = targetHeight;
                        drawWidth = targetHeight * imageAspect;
                        offsetX = (targetWidth - drawWidth) / 2; // Center horizontally
                        offsetY = 0;
                    } else {
                        // Image is taller than target, fit to width (crop top/bottom)
                        drawWidth = targetWidth;
                        drawHeight = targetWidth / imageAspect;
                        offsetX = 0;
                        offsetY = (targetHeight - drawHeight) / 2; // Center vertically
                    }

                    // Fill canvas with black background first
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(0, 0, targetWidth, targetHeight);

                    // Draw image to canvas with proper scaling
                    this.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

                    // Load and draw frame overlay
                    const frameImg = new Image();
                    frameImg.onload = () => {
                        // Draw frame overlay to cover entire canvas
                        this.ctx.drawImage(frameImg, 0, 0, targetWidth, targetHeight);
                        
                        // Show canvas with frame inside preview container
                        console.log('Showing canvas in preview container');
                        this.previewContainer.innerHTML = '';
                        this.canvasContainer.style.display = 'block';
                        this.previewContainer.appendChild(this.canvasContainer);
                        this.previewContainer.classList.add('has-content');
                        this.videoPreview.style.display = 'none';
                        this.setDownloadButtonsEnabled(true);
                        console.log('Preview container updated with canvas');
                        
                        // Debug: Log canvas dimensions and scaling info
                        console.log('=== UPLOAD IMAGE DEBUG ===');
                        console.log('Image size:', imageWidth, 'x', imageHeight);
                        console.log('Image aspect ratio:', imageAspect.toFixed(3));
                        console.log('Target aspect ratio:', targetAspect.toFixed(3));
                        console.log('Canvas size:', this.canvasOutput.width, 'x', this.canvasOutput.height);
                        console.log('Draw size:', drawWidth, 'x', drawHeight);
                        console.log('Draw offset:', offsetX, offsetY);
                        console.log('========================');
                        
                        this.currentMode = 'photo';
                        this.showStatus('Foto pernikahan berhasil diproses dengan bingkai khusus Hanum & Riduwan!', 'success');
                    };
                    frameImg.src = 'bingkai.png';
                };
                img.src = dataUrl;
            }

            processVideoFile(file) {
                console.log('=== PROCESS VIDEO FILE ===');
                console.log('Processing video file:', file.name, 'size:', file.size, 'type:', file.type);
                const videoElement = document.createElement('video');
                videoElement.src = URL.createObjectURL(file);
                videoElement.controls = true;
                videoElement.style.width = '270px';
                videoElement.style.height = '480px';
                videoElement.style.borderRadius = '10px';
                videoElement.style.objectFit = 'cover';
                videoElement.style.background = '#000';
                videoElement.muted = false; // Enable audio
                videoElement.volume = 1.0;
                
                console.log('Adding video element to preview container');
                this.previewContainer.innerHTML = '';
                this.previewContainer.appendChild(videoElement);
                this.previewContainer.classList.add('has-content');
                
                this.videoPreview.style.display = 'none';
                this.canvasContainer.style.display = 'none';
                this.setDownloadButtonsEnabled(true);
                
                this.currentMode = 'video';
                console.log('Video preview updated successfully');
                this.showStatus('Video pernikahan berhasil diupload!', 'success');
            }

            async downloadResult() {
                if (this.currentMode === 'photo') {
                    // Download canvas as image
                    this.canvasOutput.toBlob((blob) => {
                        // Debug: Log blob info and canvas dimensions
                        console.log('=== DOWNLOAD DEBUG ===');
                        console.log('Download Blob size:', blob.size, 'bytes');
                        console.log('Download Canvas internal size:', this.canvasOutput.width, 'x', this.canvasOutput.height);
                        console.log('Download Canvas display size:', this.canvasOutput.style.width, 'x', this.canvasOutput.style.height);
                        console.log('Canvas aspect ratio:', (this.canvasOutput.height / this.canvasOutput.width).toFixed(3), '(should be 1.778 for 9:16)');
                        console.log('==================');
                        
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `foto-hanum-riduwan-${Date.now()}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    });
                } else if (this.currentMode === 'video') {
                    try {
                        this.showStatus('Memproses video dengan bingkai...', 'info');
                        this.setDownloadButtonsEnabled(false);
                        this.downloadResultBtn.innerHTML = '<span class="loading"></span> Memproses...';
                        this.downloadResultPreviewBtn.innerHTML = '<span class="loading"></span> Memproses...';
                        
                        // Show progress bar and initialize
                        this.progressBar.style.display = 'block';
                        this.progressFill.style.width = '0%';
                        
                        let processedVideoBlob;
                        
                        // Handle different video sources (recorded vs uploaded)
                        if (this.recordedVideoBlob) {
                            // For recorded videos, use the stored blob
                            const videoElement = document.createElement('video');
                            videoElement.src = URL.createObjectURL(this.recordedVideoBlob);
                            videoElement.muted = false;
                            videoElement.volume = 1.0;
                            
                            await new Promise((resolve) => {
                                videoElement.onloadeddata = resolve;
                            });
                            
                                                    // Show initial progress
                        this.updateProgress(5, 'Mempersiapkan video...');
                        
                        processedVideoBlob = await this.videoProcessor.processVideo(
                            videoElement,
                            (progress) => {
                                const percentage = Math.round(progress * 100);
                                const statusText = percentage < 20 ? 'Mempersiapkan...' :
                                                 percentage < 60 ? 'Memproses video...' :
                                                 percentage < 90 ? 'Menambahkan bingkai...' :
                                                 'Finalisasi...';
                                console.log('Video Processing Progress (recorded):', percentage + '%', statusText);
                                this.updateProgress(percentage, statusText);
                            },
                            'webm' // Use WebM format for better audio-video sync
                        );
                        } else if (this.uploadedVideoFile) {
                            // For uploaded videos, use the original file
                            const videoElement = document.createElement('video');
                            videoElement.src = URL.createObjectURL(this.uploadedVideoFile);
                            videoElement.muted = false;
                            videoElement.volume = 1.0;
                            
                            await new Promise((resolve) => {
                                videoElement.onloadeddata = resolve;
                            });
                            
                                                    // Show initial progress
                        this.updateProgress(5, 'Mempersiapkan video...');
                        
                        processedVideoBlob = await this.videoProcessor.processVideo(
                            videoElement,
                            (progress) => {
                                const percentage = Math.round(progress * 100);
                                const statusText = percentage < 20 ? 'Mempersiapkan...' :
                                                 percentage < 60 ? 'Memproses video...' :
                                                 percentage < 90 ? 'Menambahkan bingkai...' :
                                                 'Finalisasi...';
                                console.log('Video Processing Progress (uploaded):', percentage + '%', statusText);
                                this.updateProgress(percentage, statusText);
                            },
                            'webm' // Use WebM format for better audio-video sync
                        );
                        } else {
                            throw new Error('Video source tidak ditemukan');
                        }

                                            // Final progress update to 100%
                    this.updateProgress(100, 'Selesai!');
                        
                        // Download processed video with appropriate extension
                        const url = URL.createObjectURL(processedVideoBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        
                        // Use WebM extension for better compatibility
                        let extension = '.webm';
                        let formatUsed = 'WebM';
                        
                        // Log blob type for debugging
                        console.log('Processed video blob type:', processedVideoBlob.type);
                        
                        // Ensure we're getting WebM format
                        if (!processedVideoBlob.type.includes('webm')) {
                            console.warn('Expected WebM but got:', processedVideoBlob.type);
                            // WebM should be the primary format for better compatibility
                        }
                        
                        a.download = `video-hanum-riduwan-${Date.now()}${extension}`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        // Show metadata info for debugging
                        try {
                            const metadata = await EnhancedVideoUtils.getVideoMetadata(processedVideoBlob);
                            console.log('Processed video metadata:', metadata);
                        } catch (e) {
                            console.log('Could not get metadata:', e);
                        }

                                            // Show enhanced success message with processing info
                    const processingMethod = this.videoProcessor.useFFmpeg ? 'FFmpeg.js (Kualitas Tinggi)' : 'MediaRecorder (Optimized)';
                    this.showStatus(`Video WebM berhasil didownload! Metode: ${processingMethod} | Ukuran: ${(processedVideoBlob.size / (1024*1024)).toFixed(1)}MB`, 'success');
                    } catch (error) {
                        this.showStatus('Gagal memproses video: ' + error.message, 'error');
                        console.error('Video processing error:', error);
                                    } finally {
                    this.resetProgress();
                }
                }
            }

            updateProgress(percentage, statusText = '') {
                this.progressFill.style.width = `${percentage}%`;
                const displayText = statusText ? `${percentage}% - ${statusText}` : `${percentage}%`;
                this.downloadResultBtn.innerHTML = `<span class="loading"></span> ${displayText}`;
                this.downloadResultPreviewBtn.innerHTML = `<span class="loading"></span> ${displayText}`;
            }
            
            resetProgress() {
                this.setDownloadButtonsEnabled(true);
                this.downloadResultBtn.innerHTML = 'Download Hasil';
                this.downloadResultPreviewBtn.innerHTML = '📥 Download Hasil';
                this.progressBar.style.display = 'none';
                this.progressFill.style.width = '0%';
            }

            resetAll() {
                this.stopCamera();
                this.previewContainer.innerHTML = `
                    <div class="placeholder">
                        <div>💒</div>
                        <p>Mulai kamera atau upload file untuk melihat preview</p>
                        <p style="font-size: 0.85rem; color: #888; margin-top: 8px;">Bingkai khusus pernikahan Hanum & Riduwan</p>
                    </div>
                `;
                this.previewContainer.classList.remove('has-content');
                this.setDownloadButtonsEnabled(false);
                this.fileInput.value = '';
                this.currentMode = null;
                this.uploadedVideoFile = null;
                this.recordedVideoBlob = null;
                this.resetProgress();
                this.showStatus('Semua data telah direset', 'info');
            }
        }

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.app = new PhotoFrameApp();
        });
    </script>
</body>
</html>
